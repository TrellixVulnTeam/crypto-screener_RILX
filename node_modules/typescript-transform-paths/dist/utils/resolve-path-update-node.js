"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePathAndUpdateNode = void 0;
const path_1 = __importDefault(require("path"));
const general_utils_1 = require("./general-utils");
/* ****************************************************************************************************************** *
 * Node Updater
 * ****************************************************************************************************************** */
/**
 * Gets proper path and calls updaterFn to get the new node if it should be updated
 */
function resolvePathAndUpdateNode(context, node, moduleName, updaterFn) {
    const { sourceFile, compilerOptions, tsInstance, config, rootDirs, implicitExtensions, factory } = context;
    /* Have Compiler API attempt to resolve */
    const { resolvedModule, failedLookupLocations } = tsInstance.resolveModuleName(moduleName, sourceFile.fileName, compilerOptions, tsInstance.sys);
    if (resolvedModule === null || resolvedModule === void 0 ? void 0 : resolvedModule.isExternalLibraryImport)
        return node;
    let outputPath;
    if (!resolvedModule) {
        const maybeURL = failedLookupLocations[0];
        if (!general_utils_1.isURL(maybeURL))
            return node;
        outputPath = maybeURL;
    }
    else {
        const { extension, resolvedFileName } = resolvedModule;
        const fileName = sourceFile.fileName;
        let filePath = tsInstance.normalizePath(path_1.default.dirname(sourceFile.fileName));
        let modulePath = path_1.default.dirname(resolvedFileName);
        /* Handle rootDirs mapping */
        if (config.useRootDirs && rootDirs) {
            let fileRootDir = "";
            let moduleRootDir = "";
            for (const rootDir of rootDirs) {
                if (general_utils_1.isBaseDir(rootDir, resolvedFileName) && rootDir.length > moduleRootDir.length)
                    moduleRootDir = rootDir;
                if (general_utils_1.isBaseDir(rootDir, fileName) && rootDir.length > fileRootDir.length)
                    fileRootDir = rootDir;
            }
            /* Remove base dirs to make relative to root */
            if (fileRootDir && moduleRootDir) {
                filePath = path_1.default.relative(fileRootDir, filePath);
                modulePath = path_1.default.relative(moduleRootDir, modulePath);
            }
        }
        /* Remove extension if implicit */
        outputPath = tsInstance.normalizePath(path_1.default.join(path_1.default.relative(filePath, modulePath), path_1.default.basename(resolvedFileName)));
        if (extension && implicitExtensions.includes(extension))
            outputPath = outputPath.slice(0, -extension.length);
        if (!outputPath)
            return node;
        outputPath = outputPath[0] === "." ? outputPath : `./${outputPath}`;
    }
    const newStringLiteral = factory.createStringLiteral(outputPath);
    return updaterFn(newStringLiteral);
}
exports.resolvePathAndUpdateNode = resolvePathAndUpdateNode;
